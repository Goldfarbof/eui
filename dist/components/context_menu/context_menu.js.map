{"version":3,"sources":["../../../src/components/context_menu/context_menu.js"],"names":["KuiContextMenu","props","onKeyDown","e","keyCode","UP","menuItems","length","preventDefault","setState","nextFocusedMenuItemIndex","prevState","focusedMenuItemIndex","DOWN","LEFT","showPreviousPanel","RIGHT","state","click","hasPreviousPanel","previousPanelId","idToPreviousPanelIdMap","panelId","currentPanelId","showPanel","resetTransitionTimeout","undefined","outGoingPanelId","initialPanelId","transitionDirection","isTransitioning","direction","clearTimeout","setTimeout","height","currentPanel","clientHeight","menu","setAttribute","querySelectorAll","focusedMenuItem","focus","tabbableItems","document","activeElement","blur","nextProps","isVisible","updateHeight","updateFocusedMenuItem","transitionType","panel","idToPanelMap","renderItems","items","map","onClick","item","window","requestAnimationFrame","bind","id","name","icon","Boolean","onClose","node","title","content","className","rest","renderPanel","outGoingPanel","classes","propTypes","children","string","oneOfType","number","bool","isRequired","object","defaultProps"],"mappings":"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","file":"context_menu.js","sourcesContent":["import React, {\n  Component,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\n\nimport { cascadingMenuKeyCodes } from '../../services';\n\nimport { KuiContextMenuPanel } from './context_menu_panel';\nimport { KuiContextMenuItem } from './context_menu_item';\n\nexport class KuiContextMenu extends Component {\n  static propTypes = {\n    children: PropTypes.node,\n    className: PropTypes.string,\n    initialPanelId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    isVisible: PropTypes.bool.isRequired,\n    idToPanelMap: PropTypes.object,\n    idToPreviousPanelIdMap: PropTypes.object,\n  }\n\n  static defaultProps = {\n    idToPanelMap: {},\n    idToPreviousPanelIdMap: {},\n    isVisible: true,\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.resetTransitionTimeout = undefined;\n    this.menuItems = [];\n\n    this.state = {\n      outGoingPanelId: undefined,\n      currentPanelId: props.initialPanelId,\n      transitionDirection: undefined,\n      isTransitioning: false,\n      focusedMenuItemIndex: 0,\n    };\n  }\n\n  onKeyDown = e => {\n    switch (e.keyCode) {\n      case cascadingMenuKeyCodes.UP:\n        if (this.menuItems.length) {\n          e.preventDefault();\n          this.setState(prevState => {\n            const nextFocusedMenuItemIndex = prevState.focusedMenuItemIndex - 1;\n            return {\n              focusedMenuItemIndex: nextFocusedMenuItemIndex < 0 ? this.menuItems.length - 1 : nextFocusedMenuItemIndex,\n            };\n          });\n        }\n        break;\n\n      case cascadingMenuKeyCodes.DOWN:\n        if (this.menuItems.length) {\n          e.preventDefault();\n          this.setState(prevState => {\n            const nextFocusedMenuItemIndex = prevState.focusedMenuItemIndex + 1;\n            return {\n              focusedMenuItemIndex: nextFocusedMenuItemIndex > this.menuItems.length - 1 ? 0 : nextFocusedMenuItemIndex,\n            };\n          });\n        }\n        break;\n\n      case cascadingMenuKeyCodes.LEFT:\n        e.preventDefault();\n        this.showPreviousPanel();\n        break;\n\n      case cascadingMenuKeyCodes.RIGHT:\n        if (this.menuItems.length) {\n          e.preventDefault();\n          this.menuItems[this.state.focusedMenuItemIndex].click();\n        }\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  hasPreviousPanel = panelId => {\n    const previousPanelId = this.props.idToPreviousPanelIdMap[panelId];\n    return typeof previousPanelId === 'number';\n  };\n\n  showPanel(panelId, direction) {\n    clearTimeout(this.resetTransitionTimeout);\n\n    this.setState({\n      outGoingPanelId: this.state.currentPanelId,\n      currentPanelId: panelId,\n      transitionDirection: direction,\n      isTransitioning: true,\n    });\n\n    // Queue the transition to reset.\n    this.resetTransitionTimeout = setTimeout(() => {\n      this.setState({\n        transitionDirection: undefined,\n        isTransitioning: false,\n        focusedMenuItemIndex: 0,\n      });\n    }, 250);\n  }\n\n  showPreviousPanel = () => {\n    // If there's a previous panel, then we can close the current panel to go back to it.\n    if (this.hasPreviousPanel(this.state.currentPanelId)) {\n      const previousPanelId = this.props.idToPreviousPanelIdMap[this.state.currentPanelId];\n      this.showPanel(previousPanelId, 'previous');\n    }\n  };\n\n  updateHeight() {\n    const height = this.currentPanel.clientHeight;\n    this.menu.setAttribute('style', `height: ${height}px`);\n  }\n\n  updateFocusedMenuItem() {\n    // When the transition completes focus on a menu item or just the menu itself.\n    if (!this.state.isTransitioning) {\n      this.menuItems = this.currentPanel.querySelectorAll('[data-menu-item]');\n      const focusedMenuItem = this.menuItems[this.state.focusedMenuItemIndex];\n      if (focusedMenuItem) {\n        focusedMenuItem.focus();\n      } else {\n        // Focus first tabbable item.\n        const tabbableItems = tabbable(this.currentPanel);\n        if (tabbableItems.length) {\n          tabbableItems[0].focus();\n        } else {\n          document.activeElement.blur();\n        }\n      }\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    // If the user is opening the context menu, reset the state.\n    if (nextProps.isVisible && !this.props.isVisible) {\n      this.setState({\n        outGoingPanelId: undefined,\n        currentPanelId: nextProps.initialPanelId,\n        transitionDirection: undefined,\n        focusedMenuItemIndex: 0,\n      });\n    }\n  }\n\n  componentDidMount() {\n    this.updateHeight();\n    this.updateFocusedMenuItem();\n  }\n\n  componentDidUpdate() {\n    // Make sure we don't steal focus while the ContextMenu is closed.\n    if (!this.props.isVisible) {\n      return;\n    }\n\n    if (this.state.isTransitioning) {\n      this.updateHeight();\n    }\n\n    this.updateFocusedMenuItem();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.resetTransitionTimeout);\n  }\n\n  renderPanel(panelId, transitionType) {\n    const panel = this.props.idToPanelMap[panelId];\n\n    if (!panel) {\n      return;\n    }\n\n    const renderItems = items => items.map(item => {\n      let onClick;\n\n      if (item.onClick) {\n        onClick = item.onClick;\n      } else if (item.panel) {\n        onClick = () => {\n          // This component is commonly wrapped in a KuiOutsideClickDetector, which means we'll\n          // need to wait for that logic to complete before re-rendering the DOM via showPanel.\n          window.requestAnimationFrame(this.showPanel.bind(this, item.panel.id, 'next'));\n        };\n      }\n\n      return (\n        <KuiContextMenuItem\n          key={item.name}\n          icon={item.icon}\n          onClick={onClick}\n          hasPanel={Boolean(item.panel)}\n          data-menu-item\n        >\n          {item.name}\n        </KuiContextMenuItem>\n      );\n    });\n\n    // As above, we need to wait for KuiOutsideClickDetector to complete its logic before\n    // re-rendering via showPanel.\n    let onClose;\n    if (this.hasPreviousPanel(panelId)) {\n      onClose = () => window.requestAnimationFrame(this.showPreviousPanel);\n    }\n\n    return (\n      <KuiContextMenuPanel\n        panelRef={node => {\n          if (transitionType === 'in') {\n            this.currentPanel = node;\n          }\n        }}\n        title={panel.title}\n        onClose={onClose}\n        transitionType={transitionType}\n        transitionDirection={this.state.transitionDirection}\n      >\n        {panel.content || renderItems(panel.items)}\n      </KuiContextMenuPanel>\n    );\n  }\n\n  render() {\n    const {\n      idToPanelMap, // eslint-disable-line no-unused-vars\n      idToPreviousPanelIdMap, // eslint-disable-line no-unused-vars\n      className,\n      initialPanelId, // eslint-disable-line no-unused-vars\n      isVisible, // eslint-disable-line no-unused-vars\n      ...rest,\n    } = this.props;\n\n    const currentPanel = this.renderPanel(this.state.currentPanelId, 'in');\n    let outGoingPanel;\n\n    // Hide the out-going panel ASAP, so it can't take focus.\n    if (this.state.isTransitioning) {\n      outGoingPanel = this.renderPanel(this.state.outGoingPanelId, 'out');\n    }\n\n    const classes = classNames('kuiContextMenu', className);\n\n    return (\n      <div\n        ref={node => { this.menu = node; }}\n        className={classes}\n        onKeyDown={this.onKeyDown}\n        {...rest}\n      >\n        {outGoingPanel}\n        {currentPanel}\n      </div>\n    );\n  }\n}\n"]}